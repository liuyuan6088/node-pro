

## haha

```javascript
// Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。

// 优点：1. 高并发（最重要的优点）

// 2. 适合I/O密集型应用

// 缺点：1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；

// 解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；

// 2. 只支持单核CPU，不能充分利用CPU

// 3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

// 原因：单进程，单线程

// 解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；

// （2）开多个进程监听同一个端口，使用cluster模块；

// 4. 开源组件库质量参差不齐，更新快，向下不兼容

// 5. Debug不方便，错误没有stack trace

// 适合NodeJS的场景
// 1. RESTful API

// 这是NodeJS最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求API，组织数据进行返回即可。它本质上只是从某个数据库中查找 一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的API需求。

// 2. 统一Web应用的UI层

// 目前MVC的架构，在某种意义上来说，Web开发有两个UI层，一个是在浏览器里面我们最终看到的，另一个在server端，负责生成和拼接页面。

// 不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成REST调用，就意味着在上层 只需要考虑如何用这些REST接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是 通过Ajax异步获取的还是通过刷新页面。

// 3. 大量Ajax请求的应用

// 例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起Ajax请求，NodeJS能响应大量的并发请求。　　总而言之，NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。

```